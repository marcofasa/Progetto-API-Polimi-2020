#include <stdlib.h>
#include <stdio.h>
#include <string.h>
int LIM=0;

typedef struct comando{
    long int p1;
    long int p2;
    char par;
}cmd;

typedef struct Stack {
    int start,finish;
    cmd instruction;
    struct Stack *next;
} uStack;

void CreateStack(struct Stack *s){
    s = NULL;
}

int Empty(struct Stack *s){
    if (s==NULL) return 0;
    else return 1;
}

struct Stack* UNDO;
struct Stack* REDO;


struct Stack* push(struct Stack *head,cmd elem)
{
    struct Stack* tmp = (struct Stack*)malloc(sizeof(struct Stack));
    tmp->instruction = elem;
    tmp->next = head;
    head = tmp;
    return head;
}

struct Stack* pop(struct Stack *head,cmd* element, int* s,int* f)
{
    element->p1=head->instruction.p1;
    element->p2=head->instruction.p2;
    element->par=head->instruction.par;
    s=head->start;
    f=head->finish;
    head=head->next;
    return head;
}


char ** Create2D(ssize_t Strings)
{
    int i;
    char **a = {0};
    a = calloc(Strings, sizeof(char *));

    for(i=0;i<Strings; i++)
    {
        a[i]=NULL;
        //a[i] = calloc(1024 , sizeof(char));

    }
    return a;
}

char ** Reallocation2D(char ** a, size_t dim, size_t molt){
    int i;
    char **b = {0};
    b = calloc(dim*molt+1, sizeof(char *));

    for (i=0; i<dim*molt+1; i++){
        b[i]=NULL;
    }

    for(i=0;i<dim;i++){
        b[i]=a[i];
    }

    //for (i=dim; i<dim*molt+1; i++){
    //b[i] = calloc(1024, sizeof(char));
    //}

    free(a);

    return b;
}

void changeundo(cmd comando, char **array, char **temp){
    long int i=comando.p1, k=comando.p2;

    while (i<=k){
        memmove(array[k],temp[LIM],1024);
        k--;
        LIM--;
    }
    LIM++;
}


void insert(cmd comando, char **array, char** temp, int dim){
    long int i=comando.p1, k=comando.p2;
    int t=dim;
    //Controlla fino a quando non arrivo a una riga non vuota
    while(1){
        if ((array[t]==NULL && array[t-1]!=NULL) || t==1) break;
        t--;
    }

    int o=t+(k-i);

    while(i<=t){
        if (array[t]==NULL) array[t]=malloc(1024*sizeof(char));
        if (array[o]==NULL) array[o]=malloc(1024*sizeof(char));
        memmove(array[o],array[t],1024);
        t--;
        o--;
    }

    while (i<=k){
        if (array[i]==NULL) array[i]=malloc(1024*sizeof(char));
        if (temp[LIM]==NULL) {
            free(array[i]);
            array[i]=NULL;
        }
        else {
            memmove(array[i], temp[LIM], 1024);
            free(temp[LIM]);
            temp[LIM] = NULL;
        }
        LIM--;
        k--;
    }
    LIM++;

}

void delete(cmd comando,char **array,char **temp, int dim){
    long int i=comando.p1, k=comando.p2;
    int j=1,t=1;
    int o=k, u=i,eof=1;

    UNDO=push(UNDO,comando);
    UNDO->start=LIM;
    UNDO->finish=LIM+(k-i);

    if(i==0) i++;

    while(i<=o){
        if (array[o]==NULL) k--;
        o--;
    }

    if (i==k && (array[i]==NULL)) eof=0;

    while (u<=k){
        temp[LIM]=array[u];
        LIM++;
        u++;
        // printf("%d\n",LIM);
    }

    while(dim>(k+j)){
        if(eof==0) break;
        if (array[k+j]!=NULL){
            if (array[i]==NULL) array[i]=malloc(1024*sizeof(char));
            memmove(array[i],array[(k+j)],1024);
        }
        else {
            free(array[k+j]);
            free(array[i]);
            array[i]=NULL;
        }
        i++;
        j++;

    }

    j=dim-((o-i)+1);

    while(j<dim)
    {
        if(eof==0)break;
        array[j]=NULL;
        j++;
    }

}

void change(cmd comando, char **array, char **temp, FILE *fp){
    size_t bufsize = 1024;
    char * string;
    long int i=comando.p1, k=comando.p2;
    //string = malloc(1024*sizeof(char));
    UNDO=push(UNDO,comando);
    UNDO->start=LIM;
    UNDO->finish=LIM+(k-i);
    //printf("%d %d %c \n",UNDO->instruction.p1,UNDO->instruction.p2,UNDO->instruction.par);

    while(i<=k){
        //if (array[i]!=NULL){
        //temp[LIM]=malloc(1024*sizeof(char));
        //memmove(temp[LIM],array[i],1024);
        //free(array[i]);}
        temp[LIM]=array[i];
        if (array[i]==NULL) array[i]=malloc(1024*sizeof(char));
        fgets(array[i],bufsize, fp);
        i++;
        LIM++;
    }
}



void undo(cmd comando, char **array,char **temp, int dim){
    cmd elem;
    long int i=0,k=comando.p1;
    int s,f;
    while (i<k){
        if (Empty(UNDO)!=0) {
            UNDO=pop(UNDO,&elem,&s,&f);
            //printf("%d %d %c", elem.p1,elem.p2,elem.par);
            REDO=push(REDO,elem);
        }
        if (Empty(UNDO)==0) {
            // printf("vuoto\n");
            break;}
        //printf("%d %d %c \n",elem.p1,elem.p2,elem.par);
        if (elem.par=='c') changeundo(elem,array,temp);
        else if (elem.par=='d') insert(elem,array,temp,dim);
        i++;
    }

}
void redo(cmd comando, char **array,char **temp, int dim){
    cmd elem;
    long int i=0, k=comando.p1;
    while (i<k){
        if(Empty(REDO)!=0){
            REDO=pop(REDO,&elem);
            UNDO=push(UNDO,elem);
        }
        if (Empty(REDO)==0) {
            // printf("vuoto\n");
            break;}
        i++;
        if (elem.par=='c') changeundo(elem,array,temp);
        else if (elem.par=='d') delete(elem,array,temp,dim);

    }
}


void print(cmd comando,char **array){
    long int i=comando.p1, k=comando.p2;
    while(i<=k){
        if (array[i]==NULL) printf(".\n");
        else printf("%s", array[i]);
        i++;
    }
}



cmd GetOrder(FILE *fp){
    size_t bufsize = 1024;
    char *string;
    cmd istr;
    string = malloc(1024*sizeof(char));
    fgets(string,bufsize, fp);

    int i=0,j=0,k=0;
    char value1[50],value2[50];

    while(1) {
        if (string[k] == 'c' || string[k] == 'p' || string[k] == 'r' || string[k] == 'u' || string[k] == 'd' ||
            string[k] == '.' || string[k] == 'q') {
            istr.par = string[k];
            break;
        }
        k++;
    }

    if (istr.par=='.'||istr.par=='q') return istr;


    if (istr.par == 'u'){
        istr.p1=atoi(&string[0]);
        istr.par=string[1];
    }
    else if (istr.par =='r') {
        istr.p1=atoi(&string[0]);
        istr.par=string[1];
    }
    else {
        while(1){
            if (string[i]==',') break;
            value1[i]=string[i];
            i++;
        }
        value1[i]='\0';

        while (string[i]!=istr.par){
            i++;
            if (string[i]==istr.par) break;
            value2[j]=string[i];
            j++;
        }
        value2[j]='\0';

        istr.p1=atoi(value1);
        istr.p2=atoi(value2);

    }
    free(string);
    return istr;
}


void interpreter(cmd comando,char** ar, char **tmp, FILE *fp,int dim){

    if (comando.par=='c')
        change(comando,ar,tmp,fp);
    else if (comando.par=='u')
        undo(comando,ar,tmp,dim);
    else if (comando.par=='r')
        redo(comando,ar,tmp,dim);
    else if (comando.par=='p')
        print(comando,ar);
    else if (comando.par=='d')
        delete(comando,ar,tmp,dim);
}


int main() {
    FILE *fp;
    cmd istruzione;
    int dim = 10, dim2=20;
    char **Array = {0};
    char **Temp = {0};
    Array = Create2D(dim);
    Temp = Create2D(dim2);
    CreateStack(UNDO);
    CreateStack(REDO);
    fp = stdin;

    while (1) {
        int molt = 0;
        istruzione = GetOrder(fp);
        if (istruzione.par == 'q') {
            break;
        }
        molt = ((istruzione.p2/ dim) + 1);
        if (dim <= istruzione.p2+1) {
            Array = Reallocation2D(Array, dim, molt);
            dim = dim * molt;
        }

        if (dim2<=(LIM+(istruzione.p2-istruzione.p1)-1)) {
             molt = ((LIM + istruzione.p2-istruzione.p1) / dim2) + 1;
             Temp = Reallocation2D(Temp, dim2, molt);
             dim2=dim2*molt;
        }
        interpreter(istruzione, Array,Temp, fp,dim);
    }

    free(Array);
    free(Temp);

    return 0;
}
