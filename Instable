
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
int LIM=0;

typedef struct comando{
    long int p1;
    long int p2;
    char par;
}cmd;

typedef struct Stack {
    int finish;
    cmd instruction;
    struct Stack *next;
} uStack;

void CreateStack(struct Stack *s){
    s = NULL;
}

int Empty(struct Stack *s){
    if (s==NULL) return 0;
    else return 1;
}

struct Stack* UNDO;
struct Stack* REDO;


struct Stack* push(struct Stack *head,cmd elem)
{
    struct Stack* tmp = (struct Stack*)malloc(sizeof(struct Stack));
    tmp->instruction = elem;
    tmp->next = head;
    head = tmp;
    return head;
}

struct Stack* pop(struct Stack *head,cmd* element)
{
    element->p1=head->instruction.p1;
    element->p2=head->instruction.p2;
    element->par=head->instruction.par;

    head=head->next;
    return head;
}


char ** Create2D(ssize_t Strings)
{
    int i;
    char **a = {0};
    a = calloc(Strings, sizeof(char *));

    for(i=0;i<Strings; i++)
    {
        a[i]=NULL;

    }
    return a;
}

char ** Reallocation2D(char ** a, size_t dim, size_t molt){
    int i;
    char **b = {0};
    b = calloc(dim*molt+1, sizeof(char *));

    for (i=0; i<dim*molt+1; i++){
        b[i]=NULL;
    }

    for(i=0;i<dim;i++){
        b[i]=a[i];
    }

    free(a);

    return b;
}

void changeundo(cmd comando, char **array, char **temp,int finish){
    int i=comando.p1, k=comando.p2;

    while (i<=k){
            char* tmp=array[k];
            array[k]=temp[finish];
            temp[finish]=tmp;
        k--;
        finish--;
    }
}


void insert(cmd comando, char **array, char** temp, int dim,int finish) {
    int i = comando.p1, k = comando.p2;
    int j=1, gap=k-i+1, eof=1, r=0;
    int io=0;
    while(io<LIM){
        printf("%d , %s \n", io,temp[io]);
        io++;
    }
    io=0;
    while(io<=dim){
        printf("%d , %s \n", io,array[io]);
        io++;
    }

    for(int t=0;t<=gap;t++){
        if (array[dim-t]!=NULL) eof=0;
    }

    while (dim-gap-r>=k){
        array[(dim-r)]=array[(dim-gap-r)];
        r++;
    }


    while (i<=k) {
        array[i]=temp[finish];
        finish--;
        i++;
    }
}

void delete(cmd comando,char **array,char **temp, int dim){
    long int i=comando.p1, k=comando.p2;
    int j=1,t=1;
    int o=k, u=i,eof=1;
    int f=LIM+(k-i);

    UNDO=push(UNDO,comando);

    for(int i=comando.p1;i<=k;i++){
        temp[LIM]=array[i];
        LIM++;
    }

    UNDO->finish=LIM-1;
    i=comando.p1;
    if(i==0) i++;

    //scalo k per rendere l'intervallo effettivo
    while(i<=o){
        if (array[o]==NULL) k--;
        o--;
    }

    if (i==k && (array[i]==NULL)) eof=0;


    while(dim>=(k+j)){
        if(eof==0)break;
        array[i]=array[k+j];
        i++;
        j++;
    }

    j=dim-((o-i)+1);

    while(j<=dim)
    {
        if(eof==0)break;
        free(array[j]);
        array[j]=NULL;
        j++;
    }
}

void change(cmd comando, char **array, char **temp, FILE *fp){
    size_t bufsize = 1024;
    long int i=comando.p1, k=comando.p2;
    int f=LIM+(k-i), strln;
    char* string=malloc(1024);

    UNDO=push(UNDO,comando);

    //printf("%d %d %c \n",UNDO->instruction.p1,UNDO->instruction.p2,UNDO->instruction.par);

    while(i<=k){
        fgets(string,bufsize, fp);

        //salvataggio per UNDO
        if (array[i]==NULL) {
            //if (temp[LIM]) free(temp[LIM]);
            temp[LIM]=NULL;
        }
        else {
                temp[LIM]=array[i];
            }

        /*if (array[i]!=NULL) {
            free(array[i]);
            array[i]=NULL;
        }*/
        strln=strlen(string)+1;
        array[i]=malloc(strln*sizeof(char));
        memmove(array[i],string,strln);
        i++;
        LIM++;
    }
    UNDO->finish=LIM-1;
    free(string);
}



void undo(cmd comando, char **array,char **temp, int dim){
    cmd elem;
    long int i=0,k=comando.p1;
    int f=0;
    while (i<k){
        if (Empty(UNDO)!=0) {
            f=UNDO->finish;
            UNDO=pop(UNDO,&elem);
            //printf("%d %d %c\n", elem.p1,elem.p2,elem.par);
            REDO=push(REDO,elem);
            REDO->finish=f;
        }
        if (Empty(UNDO)==0) {
            // printf("vuoto\n");
            break;}
        //printf("%d %d %c \n",elem.p1,elem.p2,elem.par);
        if (elem.par=='c') changeundo(elem,array,temp,f);
        else if (elem.par=='d') insert(elem,array,temp,dim,f);
        i++;
    }
}

void redo(cmd comando, char **array,char **temp, int dim){
    cmd elem;
    long int i=0, k=comando.p1;
    int f=0;

    while (i<k){
        if(Empty(REDO)!=0){
            f=REDO->finish;
            REDO=pop(REDO,&elem);
            //printf("%d %d %c", elem.p1,elem.p2,elem.par);
            UNDO=push(UNDO,elem);
            UNDO->finish=f;
        }
        else break;

        if (elem.par=='c') changeundo(elem,array,temp,f);
        else if (elem.par=='d') delete(elem,array,temp,dim);
        i++;
    }
}


void print(cmd comando,char **array){
    int i=comando.p1, k=comando.p2;
    while(i<=k){
        if (array[i]==NULL) printf(".\n");
        else printf("%s", array[i]);
        i++;
    }
}



cmd GetOrder(FILE *fp){
    size_t bufsize = 1024;
    char *string;
    cmd istr;
    string = malloc(1024*sizeof(char));
    fgets(string,bufsize, fp);

    int i=0,j=0,k=0;
    char value1[50],value2[50];

    while(1) {
        if (string[k] == 'c' || string[k] == 'p' || string[k] == 'r' || string[k] == 'u' || string[k] == 'd' ||
            string[k] == '.' || string[k] == 'q') {
            istr.par = string[k];
            break;
        }
        k++;
    }

    if (istr.par=='.'||istr.par=='q') {
        istr.p1=0;
        istr.p2=0;
        return istr;
    }


    else {
        while (1) {
            if (string[i] == ',' || string[i] == 'r' || string[i] == 'u') break;
            value1[i] = string[i];
            i++;
        }
        value1[i] = '\0';

        if (istr.par == 'u' || istr.par == 'r') {
            istr.p1 = atoi(value1);
            istr.p2=0;
        }
        else {
            while (string[i] != istr.par) {
                i++;
                if (string[i] == istr.par) break;
                value2[j] = string[i];
                j++;
            }
            value2[j] = '\0';

            istr.p1 = atoi(value1);
            istr.p2 = atoi(value2);

        }
    }
    free(string);
    return istr;
}


void interpreter(cmd comando,char** ar, char **tmp, FILE *fp,int dim){

    if (comando.par=='c')
        change(comando,ar,tmp,fp);
    else if (comando.par=='u')
        undo(comando,ar,tmp,dim);
    else if (comando.par=='r')
        redo(comando,ar,tmp,dim);
    else if (comando.par=='p')
        print(comando,ar);
    else if (comando.par=='d')
        delete(comando,ar,tmp,dim);
}


int main() {
    FILE *fp;
    cmd istruzione;
    int dim = 10, dim2=20;
    char **Array = {0};
    char **Temp = {0};
    Array = Create2D(dim);
    Temp = Create2D(dim2);
    CreateStack(UNDO);
    CreateStack(REDO);
    fp = stdin;

    while (1) {
        int molt = 0;
        istruzione = GetOrder(fp);
        //printf("\n-----------------\n%d %d %c\n", istruzione.p1,istruzione.p2,istruzione.par);
        if (istruzione.par == 'q') {
            break;
        }
        molt = ((istruzione.p2/ dim) + 1);
        if (dim <= istruzione.p2+1) {
            Array = Reallocation2D(Array, dim, molt);
            dim = dim * molt;
        }

        if (dim2<=(LIM+(istruzione.p2-istruzione.p1)-1)) {
            molt = ((LIM + istruzione.p2-istruzione.p1) / dim2) + 1;
            Temp = Reallocation2D(Temp, dim2, molt);
            dim2=dim2*molt;
        }

        //if (Empty(UNDO)!=0) printf("\n---------%d,%d,%c   to %d  ------\n",UNDO->instruction.p1,UNDO->instruction.p2,UNDO->instruction.par,UNDO->finish);
        interpreter(istruzione, Array,Temp, fp,dim);
    }

    /*int i;
     for(i=0;i<LIM;i++){
        printf("%s\n",Temp[i]);
    }*/

    free(Array);
    free(Temp);

    return 0;
}
