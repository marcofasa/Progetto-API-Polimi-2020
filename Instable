#include <stdlib.h>
#include <stdio.h>
#include <string.h>
int LIM=0;

typedef struct comando{
    long int p1;
    long int p2;
    char par;
}cmd;

typedef struct Stack {
    int finish;
    cmd instruction;
    struct Stack *next;
} uStack;

void CreateStack(struct Stack *s){
    s = NULL;
}

int Empty(struct Stack *s){
    if (s==NULL) return 0;
    else return 1;
}

struct Stack* FlushStack(struct Stack *s){
    while (s!=NULL){
        s=s->next;
    }
}

struct Stack* UNDO;
struct Stack* REDO;


struct Stack* push(struct Stack *head,cmd elem)
{
    struct Stack* tmp = (struct Stack*)malloc(sizeof(struct Stack));
    tmp->instruction = elem;
    tmp->next = head;
    head = tmp;
    return head;
}

struct Stack* pop(struct Stack *head,cmd* element)
{
    element->p1=head->instruction.p1;
    element->p2=head->instruction.p2;
    element->par=head->instruction.par;

    head=head->next;
    return head;
}


char ** Create2D(ssize_t Strings)
{
    int i;
    char **a = {0};
    a = calloc(Strings, sizeof(char *));

    for(i=0;i<Strings; i++)
    {
        a[i]=NULL;

    }
    return a;
}

char ** Reallocation2D(char ** a, size_t dim, size_t molt){
    int i;
    char **b = {0};
    b = calloc(dim*molt+1, sizeof(char *));

    for (i=0; i<dim*molt+1; i++){
        b[i]=NULL;
    }

    for(i=0;i<dim;i++){
        b[i]=a[i];
    }

    free(a);

    return b;
}

void changeundo(cmd comando, char **array, char **temp,int finish){
    int i=comando.p1, k=comando.p2;

    while (i<=k){
            char* tmp=array[k];
            array[k]=temp[finish];
            temp[finish]=tmp;
        k--;
        finish--;
    }
}


void insert(cmd comando, char **array, char** temp, int dim,int finish) {
    int i = comando.p1, k = comando.p2;
    int gap=k-i+1, r=0;
    if (i==0 && k==0) return;
    /*int io=0;
   while(io<=LIM){
        printf("%d , %s \n", io,temp[io]);
        io++;}*/

    while (dim-gap-r>=k){
        array[(dim-r)]=array[(dim-gap-r)];
        r++;
    }

    while (i<=k) {
        array[k]=temp[finish];
        finish--;
        k--;
    }
}

void deleteredo(cmd comando, char **array, int dim){
    int i=comando.p1, k=comando.p2;
    int j=1;

    if ((i==0 && k==0) || (i==k && (array[i])==NULL)) return;

    while(dim>=(k+j)){
        array[i]=array[k+j];
        i++;
        j++;
    }

    while(i<=dim){
        array[i]=NULL;
        i++;
    }
}

void delete(cmd comando,char **array,char **temp, int dim){
    int i=comando.p1, k=comando.p2;
    int j=1;
    int o=k,eof=1;
    if (i==0 && k==0) eof=0;

    //Controllo la validitÃ  dell'intervallo

    while(i<=o){
        if (array[o]==NULL) k--;
        o--;
    }
    o=k;

    if (i==k && (array[i])==NULL) eof=0;

    //Aggiusto il comando (in caso ci siano comandi nulli o con intervalli non corretti)
    comando.p2=k;

    while(i<=k){
        if(eof==0)break;
        temp[LIM]=array[i];
        LIM++;
        i++;
    }

    i=comando.p1;
    UNDO=push(UNDO,comando);
    UNDO->finish=LIM-1;
    if(i==0) i++;

    if (eof==0) return;

    //scalo k per rendere l'intervallo effettivo

    while(dim>=(k+j)){
        array[i]=array[k+j];
        i++;
        j++;

    }
    i=comando.p1;

    j=dim-((o-i)+1);

    while(j<=dim)
    {
        array[j]=NULL;
        j++;
    }
}

void change(cmd comando, char **array, char **temp, FILE *fp){
    size_t bufsize = 1024;
    int i=comando.p1, k=comando.p2;
    int strln;
    char* string=malloc(1024);

    UNDO=push(UNDO,comando);

    //printf("%d %d %c \n",UNDO->instruction.p1,UNDO->instruction.p2,UNDO->instruction.par);

    while(i<=k){
        fgets(string,bufsize, fp);
        temp[LIM]=array[i];
        strln=strlen(string)+1;
        array[i]=malloc(strln*sizeof(char));
        memmove(array[i],string,strln);
        i++;
        LIM++;
    }
    UNDO->finish=LIM-1;
    free(string);
}



void undo(cmd comando, char **array,char **temp, int dim){
    cmd elem;
    long int i=0,k=comando.p1;
    int f;
    while (i<k){
        if (Empty(UNDO)==0) {
            // printf("vuoto\n");
            break;}
        else {
            f=UNDO->finish;
            UNDO=pop(UNDO,&elem);
            //printf("%d %d %c\n", elem.p1,elem.p2,elem.par);
            REDO=push(REDO,elem);
            REDO->finish=f;
        }
        //printf("%d %d %c \n",elem.p1,elem.p2,elem.par);
        if (elem.par=='c') changeundo(elem,array,temp,f);
        else if (elem.par=='d') insert(elem,array,temp,dim,f);
        i++;
    }
}

void redo(cmd comando, char **array,char **temp, int dim){
    cmd elem;
    long int i=0, k=comando.p1;
    int f;

    while (i<k){
        if(Empty(REDO)==0){
            break;
        }
        else {
            f=REDO->finish;
            REDO=pop(REDO,&elem);
            //printf("%d %d %c", elem.p1,elem.p2,elem.par);
            UNDO=push(UNDO,elem);
            UNDO->finish=f;
        }

        if (elem.par=='c') changeundo(elem,array,temp,f);
        else if (elem.par=='d') deleteredo(elem,array,dim);
        i++;
    }
}


void print(cmd comando,char **array){
    int i=comando.p1, k=comando.p2;
    while(i<=k){
        if (array[i]==NULL) printf(".\n");
        else fputs(array[i],stdout);
        i++;
    }
}



cmd GetOrder(FILE *fp){
    size_t bufsize = 1024;
    char *string;
    cmd istr;
    string = malloc(1024*sizeof(char));
    fgets(string,bufsize, fp);

    int i=0,j=0,k=0;
    char value1[50],value2[50];

    while(1) {
        if (string[k] == 'c' || string[k] == 'p' || string[k] == 'r' || string[k] == 'u' || string[k] == 'd' ||
            string[k] == '.' || string[k] == 'q') {
            istr.par = string[k];
            break;
        }
        k++;
    }

    if (istr.par=='.'||istr.par=='q') {
        istr.p1=0;
        istr.p2=0;
        return istr;
    }


    else {
        while (1) {
            if (string[i] == ',' || string[i] == 'r' || string[i] == 'u') break;
            value1[i] = string[i];
            i++;
        }
        value1[i] = '\0';

        if (istr.par == 'u' || istr.par == 'r') {
            istr.p1 = atoi(value1);
            istr.p2=0;
        }
        else {
            while (string[i] != istr.par) {
                i++;
                if (string[i] == istr.par) break;
                value2[j] = string[i];
                j++;
            }
            value2[j] = '\0';

            istr.p1 = atoi(value1);
            istr.p2 = atoi(value2);

        }
    }
    free(string);

    if (istr.par=='c' || istr.par=='d') REDO=FlushStack(REDO);


    return istr;
}

void interpreter(cmd comando,char** ar, char **tmp, FILE *fp,int dim){

    if (comando.par=='c')
        change(comando,ar,tmp,fp);
    else if (comando.par=='u')
        undo(comando,ar,tmp,dim);
    else if (comando.par=='r')
        redo(comando,ar,tmp,dim);
    else if (comando.par=='p')
        print(comando,ar);
    else if (comando.par=='d')
        delete(comando,ar,tmp,dim);
}


int main() {
    FILE *fp;
    cmd istruzione;
    int dim = 10, dim2=20;
    char **Array = {0};
    char **Temp = {0};
    Array = Create2D(dim);
    Temp = Create2D(dim2);
    CreateStack(UNDO);
    CreateStack(REDO);
    fp = stdin;

     do {
        int molt = 0;
        istruzione = GetOrder(fp);
        //printf("\n-----------------\n%d %d %c\n", istruzione.p1,istruzione.p2,istruzione.par);
        if (istruzione.p2+1>dim) {
            molt = ((istruzione.p2/(dim-1)) + 2);
            Array = Reallocation2D(Array, dim, molt);
            dim = dim * molt;
        }

        if (dim2<(LIM+(istruzione.p2-istruzione.p1+1))) {
            molt = ((LIM + (istruzione.p2-istruzione.p1+1)) / (dim2-1)) + 2;
            Temp = Reallocation2D(Temp, dim2, molt);
            dim2=dim2*molt;
        }
        /*printf("\n-----------a----------\n");
        int io;
        io=0;
        while(io<=dim){
            printf("%d , %s \n", io,Array[io]);
            io++;
        }
        io=0;
        while(io<=LIM){
            printf("%d , %s \n", io,Temp[io]);
            io++;
        }
        printf("\n----------a-----------\n");*/
        //if (Empty(UNDO)!=0) printf("\n---------%d,%d,%c   to %d  ------\n",UNDO->instruction.p1,UNDO->instruction.p2,UNDO->instruction.par,UNDO->finish);
        interpreter(istruzione, Array,Temp, fp,dim);
    }while (istruzione.par != 'q');

    free(Array);
    free(Temp);

    return 0;
}
